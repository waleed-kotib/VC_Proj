#  tinyhttpd.tcl --
#  
#       This file is part of the whiteboard application. It implements a tiny
#       http server.
#      
#  Copyright (c) 2002-2003  Mats Bengtsson
#  
#  See the README file for license, bugs etc.
#  
# $Id: tinyhttpd.tcl,v 1.5 2003-12-08 15:52:29 matben Exp $

# ########################### USAGE ############################################
#
#   NAME
#      tinyhttpd - a tiny http server
#      
#   COMMANDS
#      ::tinyhttpd::start ?-option value ...?
#      ::tinyhttpd::stop
#      ::tinyhttpd::addmimemappings mimeList
#      ::tinyhttpd::setmimemappings mimeList
#      ::tinyhttpd::anyactive
#      ::tinyhttpd::bytestransported
#      ::tinyhttpd::avergaebytespersec
#      ::tinyhttpd::cleanup
#      
# ##############################################################################

package require Tcl 8.4
package require uriencode

package provide tinyhttpd 1.0

namespace eval ::tinyhttpd:: {
        
    # Keep track of useful things.
    variable gstate
    variable httpMsg
    variable html
    variable http
    variable opts
    variable this
    variable timing
    variable uid 0
        
    switch -- $::tcl_platform(platform) {
	macintosh {
	    set this(sep) :
	}
	windows {
	    set this(sep) {\\}
	}
	unix {
	    set this(sep) /
	}
	default {
	    set this(sep) /
	}
    }
    set this(path) [file dirname [info script]]

    set gstate(debug) 0
    
    array set httpMsg {
      200 OK
      404 "File not found on server."
    }

    # Use variables to store typical html return messages instead of files.
    set html(404) {<HTML><HEAD>
	<TITLE>File Not Found</TITLE>
	</HEAD><BODY BGCOLOR="#FFA6FF" TEXT=black>
	<FONT SIZE="5" COLOR="#CC0033" FACE="Arial,Helvetica,Verdana,sans-serif">
	<B> Error 404: The file was not found on the server. </B></FONT><P>
	<FONT SIZE="2" FACE="Arial,Helvetica,Verdana,sans-serif">
	But you can find shiny almost brand new cars at honest Mats
	used cars sales. 
	</FONT>
	</BODY></HTML>
    }
    
    # Some standard responses. Use with 'format'. Careful with spaces!
    set http(headdirlist) \
"HTTP/1.0 200 OK
Server: tinyhttpd/1.0
Last-Modified: %s
Content-Type: text/html"

    set http(404) \
"HTTP/1.0 404 $httpMsg(404)
Content-Type: text/html\n"

    set http(404GET) \
"HTTP/1.0 404 $httpMsg(404)
Content-Type: text/html
Content-Length: [string length $html(404)]\n\n$html(404)"

    set http(200) \
"HTTP/1.0 200 OK
Server: tinyhttpd/1.0
Last-Modified: %s
Content-Type: %s
Content-Length: %s\n"
    
    # These shall be used with 'format' to make html dir listings.
    set html(dirhead) "<HTML><HEAD><TITLE> %s </TITLE></HEAD>\n\
      <BODY bgcolor=#FFFFFF>\n\n\
      <!-- HTML generated by tinyhttpd -->\n\n\
      <TABLE nowrap border=0 cellpadding=2>\n\
      <TR>\n\
      \t<TD align=center nowrap height=19> %s objects </TD>\n\
      \t<TD align=left nowrap><B> Name </B></TD>\n\
      \t<TD align=right nowrap> Size </TD>\n\
      \t<TD align=left nowrap></TD>\n\
      \t<TD align=left nowrap> Type </TD>\n\
      \t<TD align=left nowrap> Date </TD>\n\
      </TR>\n\
      <TR>\n\
      \t<TD colspan=6 height=10><HR></TD>\n\
      </TR>\n"
    set html(dirline) "<TR>\n\
      \t<TD align=center nowrap height=17><a href=\"%s\">\
      <img border=0 width=16 height=16 src=\"%s\"></a></TD>\n\
      \t<TD align=left nowrap><a href=\"%s\"> %s </a></TD>\n\
      \t<TD align=right nowrap> - </TD>\n\
      \t<TD align=left nowrap></TD>\n\
      \t<TD align=left nowrap> Directory </TD>\n\
      \t<TD align=left nowrap> %s </TD>\n</TR>\n"
    set html(fileline) "<TR>\n\
      \t<TD align=center nowrap height=17><a href=\"%s\">\
      <img border=0 width=16 height=16 src=\"%s\"></a></TD>\n\
      \t<TD align=left nowrap><a href=\"%s\"> %s </a></TD>\n\
      \t<TD align=right nowrap> %s </TD>\n\
      \t<TD align=left nowrap></TD>\n\
      \t<TD align=left nowrap> %s </TD>\n\
      \t<TD align=left nowrap> %s </TD>\n</TR>\n"
    set html(dirbottom) "</TABLE>\n<BR>\n<BR>\n</BODY>\n</HTML>\n"
    
    # Default mapping from file suffix to Mime type.
    variable suffToMimeType
    array set suffToMimeType {
      .txt      text/plain
      .html     text/html
      .htm      text/html
      .text     text/plain
      .gif      image/gif
      .jpeg     image/jpeg
      .jpg      image/jpeg
      .png      image/png
      .tif      image/tiff
      .tiff     image/tiff
      .mov      video/quicktime
      .mpg      video/mpeg
      .mpeg     video/mpeg
      .mp4      video/mpeg4
      .avi      video/x-msvideo
      .aif      audio/aiff
      .aiff     audio/aiff
      .au       audio/basic
      .wav      audio/wav
      .mid      audio/midi
      .mp3      audio/mpeg
      .sdp      application/sdp
      .ps       application/postscript
      .eps      application/postscript
      .pdf      application/pdf
      .rtf      application/rtf
      .rtp      application/x-rtsp
      .rtsp     application/x-rtsp
      .tcl      application/x-tcl
      .zip      application/x-zip
      .sit      application/x-stuffit
      .gz       application/x-zip
    }
}

# tinyhttpd::start --
#
#       Start the http server.
#
# Arguments:
#       args:
#           -defaultindexfile     index.html
#	    -directorylisting     1
#	    -log                  0
#	    -logfile              httpdlog.txt
#	    -myaddr               ""
#	    -port                 80
#       
# Results:
#       server socket opened.

proc ::tinyhttpd::start {args} {
    variable opts
    variable gstate
    variable this
        
    # Any configuration options. Start with defaults, overwrite with args.
    array set opts {
	-chunk                8192
	-defaultindexfile     index.html
	-directorylisting     1
	-log                  0
	-logfile              httpdlog.txt
	-myaddr               ""
	-port                 80
    }
    set opts(-rootdirectory) $this(path)
    array set opts $args
    if {[file pathtype $opts(-rootdirectory)] != "absolute"} {
	return -code error "the path must be an absolute path"
    }
    set servopts ""
    if {$opts(-myaddr) != ""} {
	set servopts [list -myaddr $opts(-myaddr)]
    }
    if {[catch {
	eval {socket -server [namespace current]::NewChannel} $servopts \
	  $opts(-port)} msg]} {
	return -code error "Couldn't start server socket: $msg."
    }	
    set gstate(sock) $msg

    # Log file
    if {$opts(-log)} {
	if {[catch {open $opts(-logfile) a} fd]} {
	    catch {close $gstate(sock)}
	    return -code error "Failed open the log file: $opts(-logfile): $fd"
	}
	set gstate(logfd) $fd
	fconfigure $gstate(logfd) -buffering none
    }
        
    # Keep the absolute path as a list which is helpful when adding paths.
    # We typically get {{} root Tcl coccinella} on unix since first '/' is kept.
    set gstate(basePathL) {}
    foreach elem [file split $opts(-rootdirectory)] {
	lappend gstate(basePathL) [string trim $elem "/:\\"]
    }
    LogMsg "Tiny Httpd started"

    return ""
}

# tinyhttpd::NewChannel --
# 
#       Callback procedure for the server socket. Gets called whenever a new
#       client connects to the server socket.
#
# Arguments:
#	token	The token for the internal state array.
#       
# Results:
#       token

proc ::tinyhttpd::NewChannel {s ip port} {
    variable uid

    Debug 2 "NewChannel:: s=$s, ip=$ip, port=$port"

    # Initialize the state variable, an array.  We'll return the
    # name of this array as the token for the transaction.
    
    set token [namespace current]::[incr uid]
    variable $token
    upvar 0 $token state
	
    array set state {
	currentsize       0
	state             "connected"
	status            ""
    }
    array set state [list     \
      s             $s        \
      ip            $ip       \
      port          $port]    
    
    # Everything should be done with 'fileevent'.
    fconfigure $s -blocking 0 -buffering line
    fileevent $s readable [list [namespace current]::HandleRequest $token]
    
    return $token
}

# tinyhttpd::HandleRequest --
#
#       Initiates a GET or HEAD request. A sequence of callbacks completes it.
#       
# Arguments:
#	token	The token for the internal state array.
#       
# Results:
#       new fileevent procedure registered.

proc ::tinyhttpd::HandleRequest {token} {    
    variable $token
    upvar 0 $token state    
    variable gstate

    Debug 2 "HandleRequest:: $token"
    
    set s $state(s)
    set state(state) reading

    # If client closes socket.
    if {[catch {eof $s} iseof] || $iseof} {
	Finish $token eof
    } elseif {[fblocked $s]} {
	Debug 2 "\tblocked"
	return
    }
        
    # If end-of-file or because of insufficient data in nonblocking mode,
    # then gets returns -1.
    set nbytes [gets $s line]
    
    # Ignore any leading empty lines (RFC 2616, 4.1).
    if {$nbytes == 0} {
	return
    } elseif {$nbytes != -1} {
	set state(line) $line
	Debug 2 "\tline=$line"

	# We only implement the GET and HEAD operations.
	if {[regexp -nocase {^(GET|HEAD) +([^ ]*) +HTTP/([0-9]+\.[0-9]+)} \
	  $line match cmd path reqvers]} {    
	    LogMsg "$cmd: $path"
	    set state(cmd) $cmd
	    set state(path) $path
	    set state(reqvers) $reqvers
	    
	    # Set fileevent to read the sequence of 'key: value' lines.
	    fileevent $s readable   \
	      [list [namespace current]::Event $token]
	} else {
	    LogMsg "unknown request: $line"
	    Finish $token "unknown request: $line"
	}
    } else {

	# If end-of-file or because of insufficient data in nonblocking mode,
	# then gets returns -1.
	return
    }
}
	    
# tinyhttpd::Event --
#
#       Reads and processes a 'key: value' line, reschedules itself if not blank
#       line, else calls 'RespondToClient' to initiate a file transfer.
#
# Arguments:
#	token	The token for the internal state array.
#       
# Results:

proc ::tinyhttpd::Event {token} {    
    variable $token
    upvar 0 $token state    
    variable gstate
    
    set s $state(s)
    if {[catch {eof $s} iseof] || $iseof} {
	Debug 2 "Event:: eof s"
	Finish $token eof
	return
    } elseif {[fblocked $s]} {
	Debug 2 "Event:: blocked s"
	return
    }
    
    # If end-of-file or because of insufficient data in nonblocking mode,
    # then gets returns -1.
    set nbytes [gets $s line]
    Debug 3 "Event:: nbytes=$nbytes, line=$line"
    
    if {$nbytes == -1} {
	return
    } elseif {$nbytes > 0} {
	
	# Keep track of request meta data.
	if {[regexp -nocase {^([^:]+):(.+)$} $line x key value]} {
	    lappend state(meta) $key [string trim $value]
	}
	if {[regexp -nocase {^content-type:(.+)$} $line x type]} {
	    set state(content-type) [string trim $type]
	} elseif {[regexp -nocase {^content-range:(.+)$} $line x range]} {
	    set state(content-range) [string trim $range]
	}
	
    } elseif {$nbytes == 0} {
	
	# First empty line, set up file transfer.
	fileevent $s readable {}
	RespondToClient $token
    }
}

# tinyhttpd::RespondToClient --
#
#       Responds the client with the HTTP protocol, and then a number of 
#       'key: value' lines. File transfer initiated.
#       
# Arguments:
#	token	The token for the internal state array.
#       
# Results:
#       fcopy called.

proc ::tinyhttpd::RespondToClient {token} {
    global  this tcl_platform
    
    variable $token
    upvar 0 $token state    
    variable opts
    variable gstate
    variable suffToMimeType
    variable httpMsg
    variable http
    variable timing
    
    Debug 2 "RespondToClient:: $token"
            
    set s $state(s)
    set cmd $state(cmd)
    set inPath [string trimleft $state(path) /]
    Debug 2 "\tinPath=$inPath"
        
    # Decode file path.
    set inPath [uriencode::decodefile $inPath]
    Debug 2 "\tinPath=$inPath"
    
    # Join incoming decoded file path with our base directory,
    # and normalize, i.e. remove all ../
    set localPath [file normalize [file join $opts(-rootdirectory) $inPath]]
    Debug 2 "\tlocalPath=$localPath"
    
    # If no actual file given then search for the '-defaultindexfile',
    # or if no one, possibly return directory listing.
    
    if {[file isdirectory $localPath]} {
	set defFile [file join $localPath $opts(-defaultindexfile)]
	if {[file exists $defFile]} {
	    set localPath $defFile
	} elseif {$opts(-directorylisting)} {
	    
	    # No default html file exists, return directory listing.
	    set modTime [clock format [file mtime $localPath]  \
	      -format "%a, %d %b %Y %H:%M:%S GMT" -gmt 1]
	    if {[catch {
		puts $s [format $http(headdirlist) $modTime]
		
		if {[string equal $cmd "GET"]} {
		    set html [BuildHtmlDirectoryListing $opts(-rootdirectory) \
		      $inPath httpd]
		    puts $s "Content-Length: [string length $html]"
		    puts $s "\n"
		    puts $s $html
		} else {
		    puts $s "\n"
		}
	    } err]} {
		Finish $token $err
		return
	    }
	    Finish $token
	    Debug 2 "\tNo default html file exists, return directory listing."
	    return
	} else {
	    if {[catch {
		if {[string equal $cmd "GET"]} {
		    puts $s $http(404GET)
		} else {
		    puts $s $http(404)
		}
	    } err]} {
		Finish $token $err
		return
	    }
	    Finish $token ok
	    return
	}
    }
    set fext [string tolower [file extension $localPath]]
    if {[info exists suffToMimeType($fext)]} {
	set mime $suffToMimeType($fext)
    } else {
	set mime "application/octet-stream"
    }
    
    # Check that the file is there and opens correctly.
    if {$localPath == "" || [catch {open $localPath r} fd]}  {
	if {[catch {
	    if {[string equal $cmd "GET"]} {
		puts $s $http(404GET)
	    } else {
		puts $s $http(404)
	    }
	} err]} {
	    Finish $token $err
	    return
	}
	Finish $token ok
	Debug 2 "\topen $localPath failed"
	return
    } else  {
	
	# Put stuff.
	set state(fd) $fd
	set size [file size $localPath]
	set state(size) $size
	set modTime [clock format [file mtime $localPath]  \
	  -format "%a, %d %b %Y %H:%M:%S GMT" -gmt 1]
	set data [format $http(200) $modTime $mime $size]
	if {[catch {
	    puts $s $data
	    flush $s
	} err]} {
	    Finish $token $err
	    return
	}
	Debug 3 "\tdata='$data'"
    }
    if {[string equal $cmd "HEAD"]}  {
	Finish $token ok
	return
    }
    
    # If binary data.
    if {![string match "text/*" $mime]} {
	fconfigure $fd -translation binary
	fconfigure $s -translation binary
    }
    flush $s
    
    # Seems necessary (?) to avoid blocking the UI. BAD!!!
    update
    
    # Background copy. Be sure to switch off all fileevents on channel.
    fileevent $s readable {}
    fileevent $s writable {}
    fconfigure $s -buffering full
    set timing($token) [list [clock clicks -milliseconds] 0]
    
    # Initialize the stream copy.
    CopyStart $s $token
}

# tinyhttpd::CopyStart --
# 
#       The callback procedure for fcopy when copying from a disk file
#       to the socket. 
#       
# Arguments:
#	s	The socket to copy to
#	token	The token for the internal state array.
#       bytes     number of bytes in this chunk.
#       error     any error.
#       
# Results:
#       possibly reschedules itself.

proc ::tinyhttpd::CopyStart {s token} {    
    variable $token
    upvar 0 $token state    
    variable gstate
    variable opts
    
    Debug 4 "CopyStart::"

    if {[catch {
	fcopy $state(fd) $s -size $opts(-chunk) -command  \
	  [list [namespace current]::CopyDone $token]
    } err]} {
	Finish $token $err
    } 
}

# tinyhttpd::CopyDone
#
#	fcopy completion callback
#
# Arguments
#	token	The token for the internal state array.
#	bytes	The amount transfered
#
# Side Effects
#	Invokes callbacks

proc ::tinyhttpd::CopyDone {token bytes {error {}}} {    
    variable $token
    variable timing
    upvar 0 $token state

    Debug 4 "CopyDone::"

    set s $state(s)
    set fd $state(fd)
    incr state(currentsize) $bytes
    lappend timing($token) [clock clicks -milliseconds] $state(currentsize)

    # At this point the token may have been reset
    if {[string length $error] > 0} {
	Finish $token $error
    } elseif {[catch {eof $s} iseof] || $iseof} {
	Finish $token eof
    } elseif {[catch {eof $fd} iseof] || $iseof} {
	Finish $token
    } else {
	CopyStart $s $token
    }
}

proc ::tinyhttpd::Finish {token {errmsg ""}} {
    variable $token
    upvar 0 $token state    
    
    LogMsg "Finish errmsg=$errmsg"
    Debug 2 "Finish errmsg=$errmsg"
    
    if {[string length $errmsg]} {
	set state(status) $errmsg
    } else {
	set state(status) ok
    }
    set state(state) finished
    catch {close $state(s)}
    if {[info exists state(fd)]} {
	catch {close $state(fd)}
    }
    unset state
}

# tinyhttpd::stop --
# 
#       Closes the server socket. This stops new connections to take place,
#       but existing connections are kept alive.
#       
# Arguments:
#       
# Results:

proc ::tinyhttpd::stop { } {    
    variable gstate
    variable opts
    
    catch {close $gstate(sock)}
    LogMsg "Tiny Httpd stopped"
    if {$opts(-log)} {
	catch {close $gstate(logfd)}
    }
}

# tinyhttpd::anyactive --
# 
# 

proc ::tinyhttpd::anyactive { } {

    return [expr {[llength [getTokenList]] > 1} ? 1 : 0]
}

proc tinyhttpd::getTokenList { } {
    
    set ns [namespace current]
    return [concat  \
      [info vars ${ns}::\[0-9\]] \
      [info vars ${ns}::\[0-9\]\[0-9\]] \
      [info vars ${ns}::\[0-9\]\[0-9\]\[0-9\]] \
      [info vars ${ns}::\[0-9\]\[0-9\]\[0-9\]\[0-9\]] \
      [info vars ${ns}::\[0-9\]\[0-9\]\[0-9\]\[0-9\]\[0-9\]]]
}

# tinyhttpd::bytestransported --
# 
# 

proc ::tinyhttpd::bytestransported { } {
    variable timing
    
    set totbytes 0
    foreach key [array names timing "*"] {
	incr totbytes [lindex $timing($key) end]
    }
    return $totbytes
}

# tinyhttpd::avergaebytespersec --
# 
# 

proc ::tinyhttpd::avergaebytespersec { } {
    variable timing
    
    set totbytes 0
    set totms 0
    foreach key [array names timing "*"] {
	incr totbytes [lindex $timing($key) end]
	incr totms [expr [lindex $timing($key) end-1] - \
	  [lindex $timing($key) 0]]
    }
    return [expr 1000 * $totbytes / [expr $totms + 1]]
}

# tinyhttpd::cleanup --
# 
# 

proc ::tinyhttpd::cleanup { } {
    variable gstate
    variable opts
    variable timing
    
    # Not sure precisely what to do here.
    catch {close $gstate(sock)}
    if {$opts(-log)} {
	catch {close $gstate(logfd)}
    }   
    catch {unset timing}

    foreach token [getTokenList] {
	Finish $token reset
    }
}

# tinyhttpd::BuildHtmlDirectoryListing --
#
#
#       relPath        Unix style path relative 'rootDir'.
#       rootDir        The base or root directory of this http server.
#                      May be in a native style.
#       httpdRelPath
#       
# Results:
#       A complete html page describing the directory.

proc ::tinyhttpd::BuildHtmlDirectoryListing {rootDir relPath httpdRelPath} {    
    variable this
    variable html
    
    Debug 2 "----BuildHtmlDirectoryListing: rootDir=$rootDir,\
      relPath=$relPath, httpdRelPath=$httpdRelPath"
    
    # Check paths?
    if {$httpdRelPath == "/"} {
	set httpdRelPath .
    }
    
    # Make unix style paths for the icon files.
    set httpdRelPathList [split $httpdRelPath $this(sep)]
    set httpdRelPath [join $httpdRelPathList /]
    set folderIconPath "/$httpdRelPath/macfoldericon.gif"
    set fileIconPath "/$httpdRelPath/textfileicon.gif"
    
    # Add the absolute 'rootDir' path with the relative 'relPath' to form the
    # absolute path of the directory.
    set relPath [string trimleft $relPath /]
    set fullPath [AddAbsolutePathWithRelative $rootDir $relPath]
    set nativePath [file nativename $fullPath]
    
    Debug 3 "fullPath=$fullPath\n\tnativePath=$nativePath"
    
    # Set the current directory to our path (good?).
    set oldPath [pwd]
    cd $fullPath
    
    # Start by finding the directory content. 
    # glob needs the ending directory separator.
    
    set thisDir [string trim [lindex [file split $fullPath] end] "/:\\"]
    set allFiles [glob -nocomplain *]
    set totN [llength $allFiles]
    
    # Build the complete html page dynamically.    
    set htmlStuff [format $html(dirhead) $thisDir $totN]
    
    # Loop over all files and directories in our directory.
    foreach fileOrDir $allFiles {
	
	if {[catch {clock format [file mtime $fileOrDir]   \
	  -format "%a %d %b %Y, %H.%M"} res]} {
	    set dateAndTime --
	} else {
	    set dateAndTime $res
	}
	if {$relPath == ""} {
	    set link "/${fileOrDir}"
	} else {
	    set link "/${relPath}${fileOrDir}"
	}
	set link [uriencode::quotepath $link]
	
	# Is file or directory?
	if {[file isdirectory $fileOrDir]} {
	    append link /
	    append htmlStuff [format $html(dirline) $link $folderIconPath \
	      $link $fileOrDir $dateAndTime]
	} else {
	    if {[catch {file size $fileOrDir} res]} {
		set bytes 0
	    } else {
		set bytes $res
	    }
	    set formBytes [FormatBytesText $bytes]
	    append htmlStuff [format $html(fileline) $link $fileIconPath \
	      $link $fileOrDir $formBytes $fileOrDir $dateAndTime]
	}
    }
    
    # And the end.
    append htmlStuff $html(dirbottom)
    
    # Reset original working dir.
    cd $oldPath
    return $htmlStuff
}    

# tinyhttpd::AddAbsolutePathWithRelativeUnix --
#
#       Adds a relative path to an absolute path. Must be unix style paths.
#       Any "../" prepending the relative path means up one dir level.
#       This is supposed to be a lightweight 'AddAbsolutePathWithRelative' 
#       for unix style paths only.
#
# Arguments:
#       absPath       the path to start with.. Unix style!
#       relPath       the relative path that should be added. Unix style!
#       
# Results:
#       The resulting absolute path in unix style.

proc ::tinyhttpd::AddAbsolutePathWithRelativeUnix {absPath relPath} {
    
    # Construct the absolute path to the file. We need to take care of any
    # up directories "../".
    
    set absPathL [split [string trim $absPath /] /]
    
    # If any up dir (../), find how many.
    set numUp [regsub -all {\.\./} $relPath {} stripPath]
    set stripPathL [split [string trim $stripPath /] /]
    
    # Delete the same number of elements from the end of the base path
    # as there are up dirs in the relative path.
    if {$numUp > 0} {
	set iend [expr [llength $absPathL] - 1]
	set newAbsPathL [lreplace $absPathL [expr $iend - $numUp + 1] $iend]
    } else {
	set newAbsPathL $absPathL
    }
    return "/[join [concat $newAbsPathL $stripPathL] "/"]"
}

# AddAbsolutePathWithRelative ---
#
#       Adds the second, relative path, to the first, absolute path.
#       IMPORTANT: this should be just a copy of the procedure
#       with the same name in the 'SomeUtils.tcl' file.
#    
# Arguments:
#       absPath        an absolute path which is the "original" path.
#       toPath         a relative path which should be added.
#       
# Results:
#       The absolute path by adding 'absPath' with 'relPath'.

proc ::tinyhttpd::AddAbsolutePathWithRelative {absPath relPath}  {
    global  this tcl_platform
    
    # Be sure to strip off any filename.
    set absPath [getdirname $absPath]
    if {[file pathtype $absPath] != "absolute"} {
	error "first path must be an absolute path"
    } elseif {[file pathtype $relPath] != "relative"} {
	error "second path must be a relative path"
    }

    # This is the method to reach platform independence.
    # We must be sure that there are no path separators left.
    
    set absP {}
    foreach elem [file split $absPath] {
	lappend absP [string trim $elem "/:\\"]
    }
    
    # If any up dir (../ ::  ), find how many. Only unix style.
    set numUp [regsub -all {\.\./} $relPath {} newRelPath]
   
    # Delete the same number of elements from the end of the absolute path
    # as there are up dirs in the relative path.
    
    if {$numUp > 0} {
	set iend [expr [llength $absP] - 1]
	set upAbsP [lreplace $absP [expr $iend - $numUp + 1] $iend]
    } else {
	set upAbsP $absP
    }
    set relP {}
    foreach elem [file split $newRelPath] {
	lappend relP [string trim $elem "/:\\"]
    }
    set completePath "$upAbsP $relP"

    # On Windows we need special treatment of the "C:/" type drivers.
    if {$tcl_platform(platform) == "windows"} {
    	set finalAbsPath   \
	    "[lindex $completePath 0]:/[join [lrange $completePath 1 end] "/"]"
    } else {
        set finalAbsPath "/[join $completePath "/"]"
    }
    return $finalAbsPath
}

# tinyhttpd::setmimemappings --
#
#       Set the mapping from file suffix to Mime type.
#       Removes old ones.
#
# Arguments:
#       suff2MimeList
#       
# Results:
#       namespace variable 'suffToMimeType' set.

proc ::tinyhttpd::setmimemappings {suff2MimeList} {
    variable suffToMimeType
    
    # Clear out the old, set the new.
    catch {unset suffToMimeType}
    array set suffToMimeType $suff2MimeList
}

# tinyhttpd::addmimemappings --
#
#       Adds the mapping from file suffix to Mime type.
#       Keeps or replaces old ones.
#
# Arguments:
#       suff2MimeList
#       
# Results:
#       namespace variable 'suffToMimeType' set.

proc ::tinyhttpd::addmimemappings {suff2MimeList} {
    variable suffToMimeType
    
    array set suffToMimeType $suff2MimeList
}

# tinyhttpd::FormatBytesText --
#
#

proc ::tinyhttpd::FormatBytesText {bytes} {
    
    if {$bytes < 1} {
	return 0
    }
    set log10 [expr log10($bytes)]
    if {$log10 >= 6} {
	set text "[format "%3.1f" [expr $bytes/1000000.0]]M"
    } elseif {$log10>= 3} {
	set text "[format "%3.1f" [expr $bytes/1000.0]]k"
    } else {
	set text $bytes
    }
    return $text
}

proc ::tinyhttpd::Debug {num str} {
    variable gstate
    
    if {$num <= $gstate(debug)} {
	puts $str
    }
}

proc ::tinyhttpd::LogMsg {msg} {
    variable opts
    
    if {$opts(-log)} {
	catch {
	    puts $gstate(logfd) "[clock format [clock clicks]]: $msg"
	}
    }
}

#-------------------------------------------------------------------------------

